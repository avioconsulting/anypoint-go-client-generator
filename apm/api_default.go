/*
 * Partner Manager Partners API
 *
 * Anypoint Partner Manager - Partners API
 *
 * API version: v1.0.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package apm

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// DefaultApiService DefaultApi service
type DefaultApiService service

type DefaultApiApiCreateConfigurationRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	format string
	partnerId string
	environmentId string
	organizationId string
	ediFormatConfiguration *EdiFormatConfiguration
}

func (r DefaultApiApiCreateConfigurationRequest) EdiFormatConfiguration(ediFormatConfiguration EdiFormatConfiguration) DefaultApiApiCreateConfigurationRequest {
	r.ediFormatConfiguration = &ediFormatConfiguration
	return r
}

func (r DefaultApiApiCreateConfigurationRequest) Execute() (InlineResponse202, *_nethttp.Response, error) {
	return r.ApiService.CreateConfigurationExecute(r)
}

/*
 * CreateConfiguration Method for CreateConfiguration
 * Create a new configuration
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param format
 * @param partnerId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiCreateConfigurationRequest
 */
func (a *DefaultApiService) CreateConfiguration(ctx _context.Context, format string, partnerId string, environmentId string, organizationId string) DefaultApiApiCreateConfigurationRequest {
	return DefaultApiApiCreateConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		format: format,
		partnerId: partnerId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse202
 */
func (a *DefaultApiService) CreateConfigurationExecute(r DefaultApiApiCreateConfigurationRequest) (InlineResponse202, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse202
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateConfiguration")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partners/{partnerId}/ediFormats/{format}/configurations"
	localVarPath = strings.Replace(localVarPath, "{"+"format"+"}", _neturl.PathEscape(parameterToString(r.format, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partnerId"+"}", _neturl.PathEscape(parameterToString(r.partnerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.ediFormatConfiguration == nil {
		return localVarReturnValue, nil, reportError("ediFormatConfiguration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.ediFormatConfiguration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiCreateContactRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	partnerId string
	environmentId string
	organizationId string
	contact *Contact
}

func (r DefaultApiApiCreateContactRequest) Contact(contact Contact) DefaultApiApiCreateContactRequest {
	r.contact = &contact
	return r
}

func (r DefaultApiApiCreateContactRequest) Execute() (InlineResponse202, *_nethttp.Response, error) {
	return r.ApiService.CreateContactExecute(r)
}

/*
 * CreateContact Method for CreateContact
 * Create a new contact
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param partnerId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiCreateContactRequest
 */
func (a *DefaultApiService) CreateContact(ctx _context.Context, partnerId string, environmentId string, organizationId string) DefaultApiApiCreateContactRequest {
	return DefaultApiApiCreateContactRequest{
		ApiService: a,
		ctx: ctx,
		partnerId: partnerId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse202
 */
func (a *DefaultApiService) CreateContactExecute(r DefaultApiApiCreateContactRequest) (InlineResponse202, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse202
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateContact")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partners/{partnerId}/contacts"
	localVarPath = strings.Replace(localVarPath, "{"+"partnerId"+"}", _neturl.PathEscape(parameterToString(r.partnerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.contact == nil {
		return localVarReturnValue, nil, reportError("contact is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.contact
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiCreateCustomAttributeRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	environmentId string
	organizationId string
	partnerId *string
	customAttribute *CustomAttribute
}

func (r DefaultApiApiCreateCustomAttributeRequest) PartnerId(partnerId string) DefaultApiApiCreateCustomAttributeRequest {
	r.partnerId = &partnerId
	return r
}
func (r DefaultApiApiCreateCustomAttributeRequest) CustomAttribute(customAttribute CustomAttribute) DefaultApiApiCreateCustomAttributeRequest {
	r.customAttribute = &customAttribute
	return r
}

func (r DefaultApiApiCreateCustomAttributeRequest) Execute() (InlineResponse202, *_nethttp.Response, error) {
	return r.ApiService.CreateCustomAttributeExecute(r)
}

/*
 * CreateCustomAttribute Method for CreateCustomAttribute
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiCreateCustomAttributeRequest
 */
func (a *DefaultApiService) CreateCustomAttribute(ctx _context.Context, environmentId string, organizationId string) DefaultApiApiCreateCustomAttributeRequest {
	return DefaultApiApiCreateCustomAttributeRequest{
		ApiService: a,
		ctx: ctx,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse202
 */
func (a *DefaultApiService) CreateCustomAttributeExecute(r DefaultApiApiCreateCustomAttributeRequest) (InlineResponse202, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse202
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateCustomAttribute")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/customAttributes"
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.partnerId == nil {
		return localVarReturnValue, nil, reportError("partnerId is required and must be specified")
	}
	if r.customAttribute == nil {
		return localVarReturnValue, nil, reportError("customAttribute is required and must be specified")
	}

	localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.customAttribute
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiCreateDeploymentConfigurationRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	environmentId string
	organizationId string
	deploymentPostRequest *DeploymentPostRequest
}

func (r DefaultApiApiCreateDeploymentConfigurationRequest) DeploymentPostRequest(deploymentPostRequest DeploymentPostRequest) DefaultApiApiCreateDeploymentConfigurationRequest {
	r.deploymentPostRequest = &deploymentPostRequest
	return r
}

func (r DefaultApiApiCreateDeploymentConfigurationRequest) Execute() (CreateEntityResponse, *_nethttp.Response, error) {
	return r.ApiService.CreateDeploymentConfigurationExecute(r)
}

/*
 * CreateDeploymentConfiguration Method for CreateDeploymentConfiguration
 * Creates new Deployment config
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiCreateDeploymentConfigurationRequest
 */
func (a *DefaultApiService) CreateDeploymentConfiguration(ctx _context.Context, environmentId string, organizationId string) DefaultApiApiCreateDeploymentConfigurationRequest {
	return DefaultApiApiCreateDeploymentConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return CreateEntityResponse
 */
func (a *DefaultApiService) CreateDeploymentConfigurationExecute(r DefaultApiApiCreateDeploymentConfigurationRequest) (CreateEntityResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CreateEntityResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateDeploymentConfiguration")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/deployments"
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.deploymentPostRequest == nil {
		return localVarReturnValue, nil, reportError("deploymentPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deploymentPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiCreateDocumentRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	partnerId string
	environmentId string
	organizationId string
	document *Document
}

func (r DefaultApiApiCreateDocumentRequest) Document(document Document) DefaultApiApiCreateDocumentRequest {
	r.document = &document
	return r
}

func (r DefaultApiApiCreateDocumentRequest) Execute() (InlineResponse202, *_nethttp.Response, error) {
	return r.ApiService.CreateDocumentExecute(r)
}

/*
 * CreateDocument Method for CreateDocument
 * Create a new document
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param partnerId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiCreateDocumentRequest
 */
func (a *DefaultApiService) CreateDocument(ctx _context.Context, partnerId string, environmentId string, organizationId string) DefaultApiApiCreateDocumentRequest {
	return DefaultApiApiCreateDocumentRequest{
		ApiService: a,
		ctx: ctx,
		partnerId: partnerId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse202
 */
func (a *DefaultApiService) CreateDocumentExecute(r DefaultApiApiCreateDocumentRequest) (InlineResponse202, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse202
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateDocument")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partners/{partnerId}/documents"
	localVarPath = strings.Replace(localVarPath, "{"+"partnerId"+"}", _neturl.PathEscape(parameterToString(r.partnerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.document == nil {
		return localVarReturnValue, nil, reportError("document is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.document
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiCreateDocumentflowRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	environmentId string
	organizationId string
	documentFlow *DocumentFlow
}

func (r DefaultApiApiCreateDocumentflowRequest) DocumentFlow(documentFlow DocumentFlow) DefaultApiApiCreateDocumentflowRequest {
	r.documentFlow = &documentFlow
	return r
}

func (r DefaultApiApiCreateDocumentflowRequest) Execute() (InlineResponse202, *_nethttp.Response, error) {
	return r.ApiService.CreateDocumentflowExecute(r)
}

/*
 * CreateDocumentflow Method for CreateDocumentflow
 * Create a new documentflow
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiCreateDocumentflowRequest
 */
func (a *DefaultApiService) CreateDocumentflow(ctx _context.Context, environmentId string, organizationId string) DefaultApiApiCreateDocumentflowRequest {
	return DefaultApiApiCreateDocumentflowRequest{
		ApiService: a,
		ctx: ctx,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse202
 */
func (a *DefaultApiService) CreateDocumentflowExecute(r DefaultApiApiCreateDocumentflowRequest) (InlineResponse202, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse202
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateDocumentflow")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/documentflows"
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.documentFlow == nil {
		return localVarReturnValue, nil, reportError("documentFlow is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.documentFlow
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiCreateEdiFormatDocumentRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	format string
	partnerId string
	environmentId string
	organizationId string
	body *map[string]interface{}
}

func (r DefaultApiApiCreateEdiFormatDocumentRequest) Body(body map[string]interface{}) DefaultApiApiCreateEdiFormatDocumentRequest {
	r.body = &body
	return r
}

func (r DefaultApiApiCreateEdiFormatDocumentRequest) Execute() (InlineResponse202, *_nethttp.Response, error) {
	return r.ApiService.CreateEdiFormatDocumentExecute(r)
}

/*
 * CreateEdiFormatDocument Method for CreateEdiFormatDocument
 * Create a new document
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param format
 * @param partnerId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiCreateEdiFormatDocumentRequest
 */
func (a *DefaultApiService) CreateEdiFormatDocument(ctx _context.Context, format string, partnerId string, environmentId string, organizationId string) DefaultApiApiCreateEdiFormatDocumentRequest {
	return DefaultApiApiCreateEdiFormatDocumentRequest{
		ApiService: a,
		ctx: ctx,
		format: format,
		partnerId: partnerId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse202
 */
func (a *DefaultApiService) CreateEdiFormatDocumentExecute(r DefaultApiApiCreateEdiFormatDocumentRequest) (InlineResponse202, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse202
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateEdiFormatDocument")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partners/{partnerId}/ediFormats/{format}/documents"
	localVarPath = strings.Replace(localVarPath, "{"+"format"+"}", _neturl.PathEscape(parameterToString(r.format, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partnerId"+"}", _neturl.PathEscape(parameterToString(r.partnerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiCreateEndpointRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	environmentId string
	organizationId string
	endpoint *Endpoint
}

func (r DefaultApiApiCreateEndpointRequest) Endpoint(endpoint Endpoint) DefaultApiApiCreateEndpointRequest {
	r.endpoint = &endpoint
	return r
}

func (r DefaultApiApiCreateEndpointRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.CreateEndpointExecute(r)
}

/*
 * CreateEndpoint Method for CreateEndpoint
 * Create a new endpoint
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiCreateEndpointRequest
 */
func (a *DefaultApiService) CreateEndpoint(ctx _context.Context, environmentId string, organizationId string) DefaultApiApiCreateEndpointRequest {
	return DefaultApiApiCreateEndpointRequest{
		ApiService: a,
		ctx: ctx,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return string
 */
func (a *DefaultApiService) CreateEndpointExecute(r DefaultApiApiCreateEndpointRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateEndpoint")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/endpoints"
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.endpoint == nil {
		return localVarReturnValue, nil, reportError("endpoint is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.endpoint
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiCreateIdentifierRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	partnerId string
	environmentId string
	organizationId string
	identifier *Identifier
}

func (r DefaultApiApiCreateIdentifierRequest) Identifier(identifier Identifier) DefaultApiApiCreateIdentifierRequest {
	r.identifier = &identifier
	return r
}

func (r DefaultApiApiCreateIdentifierRequest) Execute() (InlineResponse202, *_nethttp.Response, error) {
	return r.ApiService.CreateIdentifierExecute(r)
}

/*
 * CreateIdentifier Method for CreateIdentifier
 * Create a new identifier
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param partnerId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiCreateIdentifierRequest
 */
func (a *DefaultApiService) CreateIdentifier(ctx _context.Context, partnerId string, environmentId string, organizationId string) DefaultApiApiCreateIdentifierRequest {
	return DefaultApiApiCreateIdentifierRequest{
		ApiService: a,
		ctx: ctx,
		partnerId: partnerId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse202
 */
func (a *DefaultApiService) CreateIdentifierExecute(r DefaultApiApiCreateIdentifierRequest) (InlineResponse202, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse202
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateIdentifier")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partners/{partnerId}/identifiers"
	localVarPath = strings.Replace(localVarPath, "{"+"partnerId"+"}", _neturl.PathEscape(parameterToString(r.partnerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.identifier == nil {
		return localVarReturnValue, nil, reportError("identifier is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifier
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiCreateMappingRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	documentflowId string
	environmentId string
	organizationId string
	documentMappingConfig *DocumentMappingConfig
}

func (r DefaultApiApiCreateMappingRequest) DocumentMappingConfig(documentMappingConfig DocumentMappingConfig) DefaultApiApiCreateMappingRequest {
	r.documentMappingConfig = &documentMappingConfig
	return r
}

func (r DefaultApiApiCreateMappingRequest) Execute() (InlineResponse202, *_nethttp.Response, error) {
	return r.ApiService.CreateMappingExecute(r)
}

/*
 * CreateMapping Method for CreateMapping
 * Create a new mapping
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param documentflowId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiCreateMappingRequest
 */
func (a *DefaultApiService) CreateMapping(ctx _context.Context, documentflowId string, environmentId string, organizationId string) DefaultApiApiCreateMappingRequest {
	return DefaultApiApiCreateMappingRequest{
		ApiService: a,
		ctx: ctx,
		documentflowId: documentflowId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse202
 */
func (a *DefaultApiService) CreateMappingExecute(r DefaultApiApiCreateMappingRequest) (InlineResponse202, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse202
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateMapping")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/documentflows/{documentflowId}/mappings"
	localVarPath = strings.Replace(localVarPath, "{"+"documentflowId"+"}", _neturl.PathEscape(parameterToString(r.documentflowId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.documentMappingConfig == nil {
		return localVarReturnValue, nil, reportError("documentMappingConfig is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.documentMappingConfig
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiCreatePartnerRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	environmentId string
	organizationId string
	partner *Partner
}

func (r DefaultApiApiCreatePartnerRequest) Partner(partner Partner) DefaultApiApiCreatePartnerRequest {
	r.partner = &partner
	return r
}

func (r DefaultApiApiCreatePartnerRequest) Execute() (InlineResponse202, *_nethttp.Response, error) {
	return r.ApiService.CreatePartnerExecute(r)
}

/*
 * CreatePartner Method for CreatePartner
 * Create a new partner
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiCreatePartnerRequest
 */
func (a *DefaultApiService) CreatePartner(ctx _context.Context, environmentId string, organizationId string) DefaultApiApiCreatePartnerRequest {
	return DefaultApiApiCreatePartnerRequest{
		ApiService: a,
		ctx: ctx,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse202
 */
func (a *DefaultApiService) CreatePartnerExecute(r DefaultApiApiCreatePartnerRequest) (InlineResponse202, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse202
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreatePartner")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partners"
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.partner == nil {
		return localVarReturnValue, nil, reportError("partner is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.partner
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiCreatePartnerCertificateRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	partnerId string
	environmentId string
	organizationId string
	certType *string
	certName *string
	certFile *string
}

func (r DefaultApiApiCreatePartnerCertificateRequest) CertType(certType string) DefaultApiApiCreatePartnerCertificateRequest {
	r.certType = &certType
	return r
}
func (r DefaultApiApiCreatePartnerCertificateRequest) CertName(certName string) DefaultApiApiCreatePartnerCertificateRequest {
	r.certName = &certName
	return r
}
func (r DefaultApiApiCreatePartnerCertificateRequest) CertFile(certFile string) DefaultApiApiCreatePartnerCertificateRequest {
	r.certFile = &certFile
	return r
}

func (r DefaultApiApiCreatePartnerCertificateRequest) Execute() (InlineResponse202, *_nethttp.Response, error) {
	return r.ApiService.CreatePartnerCertificateExecute(r)
}

/*
 * CreatePartnerCertificate Method for CreatePartnerCertificate
 * Create a new Certificate
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param partnerId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiCreatePartnerCertificateRequest
 */
func (a *DefaultApiService) CreatePartnerCertificate(ctx _context.Context, partnerId string, environmentId string, organizationId string) DefaultApiApiCreatePartnerCertificateRequest {
	return DefaultApiApiCreatePartnerCertificateRequest{
		ApiService: a,
		ctx: ctx,
		partnerId: partnerId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse202
 */
func (a *DefaultApiService) CreatePartnerCertificateExecute(r DefaultApiApiCreatePartnerCertificateRequest) (InlineResponse202, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse202
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreatePartnerCertificate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partners/{partnerId}/certificates"
	localVarPath = strings.Replace(localVarPath, "{"+"partnerId"+"}", _neturl.PathEscape(parameterToString(r.partnerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.certType == nil {
		return localVarReturnValue, nil, reportError("certType is required and must be specified")
	}
	if r.certName == nil {
		return localVarReturnValue, nil, reportError("certName is required and must be specified")
	}
	if r.certFile == nil {
		return localVarReturnValue, nil, reportError("certFile is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("certType", parameterToString(*r.certType, ""))
	localVarFormParams.Add("certName", parameterToString(*r.certName, ""))
	localVarFormParams.Add("certFile", parameterToString(*r.certFile, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiCreatePartnerProfileRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	environmentId string
	organizationId string
	partnerprofile *Partnerprofile
}

func (r DefaultApiApiCreatePartnerProfileRequest) Partnerprofile(partnerprofile Partnerprofile) DefaultApiApiCreatePartnerProfileRequest {
	r.partnerprofile = &partnerprofile
	return r
}

func (r DefaultApiApiCreatePartnerProfileRequest) Execute() (InlineResponse202, *_nethttp.Response, error) {
	return r.ApiService.CreatePartnerProfileExecute(r)
}

/*
 * CreatePartnerProfile Method for CreatePartnerProfile
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiCreatePartnerProfileRequest
 */
func (a *DefaultApiService) CreatePartnerProfile(ctx _context.Context, environmentId string, organizationId string) DefaultApiApiCreatePartnerProfileRequest {
	return DefaultApiApiCreatePartnerProfileRequest{
		ApiService: a,
		ctx: ctx,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse202
 */
func (a *DefaultApiService) CreatePartnerProfileExecute(r DefaultApiApiCreatePartnerProfileRequest) (InlineResponse202, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse202
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreatePartnerProfile")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partnerprofiles"
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.partnerprofile == nil {
		return localVarReturnValue, nil, reportError("partnerprofile is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.partnerprofile
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiDeleteConfigurationRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	configId string
	format string
	partnerId string
	environmentId string
	organizationId string
}


func (r DefaultApiApiDeleteConfigurationRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteConfigurationExecute(r)
}

/*
 * DeleteConfiguration Method for DeleteConfiguration
 * Delete configuration
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param configId
 * @param format
 * @param partnerId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiDeleteConfigurationRequest
 */
func (a *DefaultApiService) DeleteConfiguration(ctx _context.Context, configId string, format string, partnerId string, environmentId string, organizationId string) DefaultApiApiDeleteConfigurationRequest {
	return DefaultApiApiDeleteConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		configId: configId,
		format: format,
		partnerId: partnerId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) DeleteConfigurationExecute(r DefaultApiApiDeleteConfigurationRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteConfiguration")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partners/{partnerId}/ediFormats/{format}/configurations/{configId}"
	localVarPath = strings.Replace(localVarPath, "{"+"configId"+"}", _neturl.PathEscape(parameterToString(r.configId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"format"+"}", _neturl.PathEscape(parameterToString(r.format, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partnerId"+"}", _neturl.PathEscape(parameterToString(r.partnerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultApiApiDeleteContactRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	contactId string
	partnerId string
	environmentId string
	organizationId string
}


func (r DefaultApiApiDeleteContactRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteContactExecute(r)
}

/*
 * DeleteContact Method for DeleteContact
 * Delete contact
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param contactId
 * @param partnerId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiDeleteContactRequest
 */
func (a *DefaultApiService) DeleteContact(ctx _context.Context, contactId string, partnerId string, environmentId string, organizationId string) DefaultApiApiDeleteContactRequest {
	return DefaultApiApiDeleteContactRequest{
		ApiService: a,
		ctx: ctx,
		contactId: contactId,
		partnerId: partnerId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) DeleteContactExecute(r DefaultApiApiDeleteContactRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteContact")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partners/{partnerId}/contacts/{contactId}"
	localVarPath = strings.Replace(localVarPath, "{"+"contactId"+"}", _neturl.PathEscape(parameterToString(r.contactId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partnerId"+"}", _neturl.PathEscape(parameterToString(r.partnerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultApiApiDeleteCustomAttributeRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	customAttributeId string
	environmentId string
	organizationId string
}


func (r DefaultApiApiDeleteCustomAttributeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteCustomAttributeExecute(r)
}

/*
 * DeleteCustomAttribute Method for DeleteCustomAttribute
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param customAttributeId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiDeleteCustomAttributeRequest
 */
func (a *DefaultApiService) DeleteCustomAttribute(ctx _context.Context, customAttributeId string, environmentId string, organizationId string) DefaultApiApiDeleteCustomAttributeRequest {
	return DefaultApiApiDeleteCustomAttributeRequest{
		ApiService: a,
		ctx: ctx,
		customAttributeId: customAttributeId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) DeleteCustomAttributeExecute(r DefaultApiApiDeleteCustomAttributeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteCustomAttribute")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/customAttributes/{customAttributeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"customAttributeId"+"}", _neturl.PathEscape(parameterToString(r.customAttributeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultApiApiDeleteDocumentRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	documentById string
	partnerId string
	environmentId string
	organizationId string
}


func (r DefaultApiApiDeleteDocumentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteDocumentExecute(r)
}

/*
 * DeleteDocument Method for DeleteDocument
 * Delete document
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param documentById
 * @param partnerId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiDeleteDocumentRequest
 */
func (a *DefaultApiService) DeleteDocument(ctx _context.Context, documentById string, partnerId string, environmentId string, organizationId string) DefaultApiApiDeleteDocumentRequest {
	return DefaultApiApiDeleteDocumentRequest{
		ApiService: a,
		ctx: ctx,
		documentById: documentById,
		partnerId: partnerId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) DeleteDocumentExecute(r DefaultApiApiDeleteDocumentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteDocument")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partners/{partnerId}/documents/{documentById}"
	localVarPath = strings.Replace(localVarPath, "{"+"documentById"+"}", _neturl.PathEscape(parameterToString(r.documentById, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partnerId"+"}", _neturl.PathEscape(parameterToString(r.partnerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultApiApiDeleteDocumentflowRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	documentflowId string
	environmentId string
	organizationId string
}


func (r DefaultApiApiDeleteDocumentflowRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteDocumentflowExecute(r)
}

/*
 * DeleteDocumentflow Method for DeleteDocumentflow
 * Delete documentflow
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param documentflowId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiDeleteDocumentflowRequest
 */
func (a *DefaultApiService) DeleteDocumentflow(ctx _context.Context, documentflowId string, environmentId string, organizationId string) DefaultApiApiDeleteDocumentflowRequest {
	return DefaultApiApiDeleteDocumentflowRequest{
		ApiService: a,
		ctx: ctx,
		documentflowId: documentflowId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) DeleteDocumentflowExecute(r DefaultApiApiDeleteDocumentflowRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteDocumentflow")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/documentflows/{documentflowId}"
	localVarPath = strings.Replace(localVarPath, "{"+"documentflowId"+"}", _neturl.PathEscape(parameterToString(r.documentflowId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultApiApiDeleteEdiFormatDocumentRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	docId string
	format string
	partnerId string
	environmentId string
	organizationId string
}


func (r DefaultApiApiDeleteEdiFormatDocumentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteEdiFormatDocumentExecute(r)
}

/*
 * DeleteEdiFormatDocument Method for DeleteEdiFormatDocument
 * Delete document
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param docId
 * @param format
 * @param partnerId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiDeleteEdiFormatDocumentRequest
 */
func (a *DefaultApiService) DeleteEdiFormatDocument(ctx _context.Context, docId string, format string, partnerId string, environmentId string, organizationId string) DefaultApiApiDeleteEdiFormatDocumentRequest {
	return DefaultApiApiDeleteEdiFormatDocumentRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		format: format,
		partnerId: partnerId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) DeleteEdiFormatDocumentExecute(r DefaultApiApiDeleteEdiFormatDocumentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteEdiFormatDocument")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partners/{partnerId}/ediFormats/{format}/documents/{docId}"
	localVarPath = strings.Replace(localVarPath, "{"+"docId"+"}", _neturl.PathEscape(parameterToString(r.docId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"format"+"}", _neturl.PathEscape(parameterToString(r.format, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partnerId"+"}", _neturl.PathEscape(parameterToString(r.partnerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultApiApiDeleteEndpointRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	endpointId string
	environmentId string
	organizationId string
}


func (r DefaultApiApiDeleteEndpointRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteEndpointExecute(r)
}

/*
 * DeleteEndpoint Method for DeleteEndpoint
 * Delete endpoint
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param endpointId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiDeleteEndpointRequest
 */
func (a *DefaultApiService) DeleteEndpoint(ctx _context.Context, endpointId string, environmentId string, organizationId string) DefaultApiApiDeleteEndpointRequest {
	return DefaultApiApiDeleteEndpointRequest{
		ApiService: a,
		ctx: ctx,
		endpointId: endpointId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) DeleteEndpointExecute(r DefaultApiApiDeleteEndpointRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteEndpoint")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/endpoints/{endpointId}"
	localVarPath = strings.Replace(localVarPath, "{"+"endpointId"+"}", _neturl.PathEscape(parameterToString(r.endpointId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultApiApiDeleteIdentifierRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	identifierId string
	partnerId string
	environmentId string
	organizationId string
}


func (r DefaultApiApiDeleteIdentifierRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteIdentifierExecute(r)
}

/*
 * DeleteIdentifier Method for DeleteIdentifier
 * Delete identifier
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param identifierId
 * @param partnerId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiDeleteIdentifierRequest
 */
func (a *DefaultApiService) DeleteIdentifier(ctx _context.Context, identifierId string, partnerId string, environmentId string, organizationId string) DefaultApiApiDeleteIdentifierRequest {
	return DefaultApiApiDeleteIdentifierRequest{
		ApiService: a,
		ctx: ctx,
		identifierId: identifierId,
		partnerId: partnerId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) DeleteIdentifierExecute(r DefaultApiApiDeleteIdentifierRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteIdentifier")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partners/{partnerId}/identifiers/{identifierId}"
	localVarPath = strings.Replace(localVarPath, "{"+"identifierId"+"}", _neturl.PathEscape(parameterToString(r.identifierId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partnerId"+"}", _neturl.PathEscape(parameterToString(r.partnerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultApiApiDeleteMappingRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	mappingsId string
	documentflowId string
	environmentId string
	organizationId string
}


func (r DefaultApiApiDeleteMappingRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteMappingExecute(r)
}

/*
 * DeleteMapping Method for DeleteMapping
 * Delete mapping
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param mappingsId
 * @param documentflowId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiDeleteMappingRequest
 */
func (a *DefaultApiService) DeleteMapping(ctx _context.Context, mappingsId string, documentflowId string, environmentId string, organizationId string) DefaultApiApiDeleteMappingRequest {
	return DefaultApiApiDeleteMappingRequest{
		ApiService: a,
		ctx: ctx,
		mappingsId: mappingsId,
		documentflowId: documentflowId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) DeleteMappingExecute(r DefaultApiApiDeleteMappingRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteMapping")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/documentflows/{documentflowId}/mappings/{mappingsId}"
	localVarPath = strings.Replace(localVarPath, "{"+"mappingsId"+"}", _neturl.PathEscape(parameterToString(r.mappingsId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"documentflowId"+"}", _neturl.PathEscape(parameterToString(r.documentflowId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultApiApiDeletePartnerRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	partnerId string
	environmentId string
	organizationId string
}


func (r DefaultApiApiDeletePartnerRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeletePartnerExecute(r)
}

/*
 * DeletePartner Method for DeletePartner
 * Delete partner
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param partnerId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiDeletePartnerRequest
 */
func (a *DefaultApiService) DeletePartner(ctx _context.Context, partnerId string, environmentId string, organizationId string) DefaultApiApiDeletePartnerRequest {
	return DefaultApiApiDeletePartnerRequest{
		ApiService: a,
		ctx: ctx,
		partnerId: partnerId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) DeletePartnerExecute(r DefaultApiApiDeletePartnerRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeletePartner")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partners/{partnerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"partnerId"+"}", _neturl.PathEscape(parameterToString(r.partnerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultApiApiDeletePartnerProfileRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	partnerId string
	environmentId string
	organizationId string
}


func (r DefaultApiApiDeletePartnerProfileRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeletePartnerProfileExecute(r)
}

/*
 * DeletePartnerProfile Method for DeletePartnerProfile
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param partnerId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiDeletePartnerProfileRequest
 */
func (a *DefaultApiService) DeletePartnerProfile(ctx _context.Context, partnerId string, environmentId string, organizationId string) DefaultApiApiDeletePartnerProfileRequest {
	return DefaultApiApiDeletePartnerProfileRequest{
		ApiService: a,
		ctx: ctx,
		partnerId: partnerId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) DeletePartnerProfileExecute(r DefaultApiApiDeletePartnerProfileRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeletePartnerProfile")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partnerprofiles/{partnerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"partnerId"+"}", _neturl.PathEscape(parameterToString(r.partnerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultApiApiGetAllCertificatesRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	partnerId string
	environmentId string
	organizationId string
}


func (r DefaultApiApiGetAllCertificatesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetAllCertificatesExecute(r)
}

/*
 * GetAllCertificates Method for GetAllCertificates
 * Get all Certificates
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param partnerId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiGetAllCertificatesRequest
 */
func (a *DefaultApiService) GetAllCertificates(ctx _context.Context, partnerId string, environmentId string, organizationId string) DefaultApiApiGetAllCertificatesRequest {
	return DefaultApiApiGetAllCertificatesRequest{
		ApiService: a,
		ctx: ctx,
		partnerId: partnerId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) GetAllCertificatesExecute(r DefaultApiApiGetAllCertificatesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetAllCertificates")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partners/{partnerId}/certificates"
	localVarPath = strings.Replace(localVarPath, "{"+"partnerId"+"}", _neturl.PathEscape(parameterToString(r.partnerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultApiApiGetAllConfigurationsRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	format string
	partnerId string
	environmentId string
	organizationId string
}


func (r DefaultApiApiGetAllConfigurationsRequest) Execute() ([]map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.GetAllConfigurationsExecute(r)
}

/*
 * GetAllConfigurations Method for GetAllConfigurations
 * Get all configurations
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param format
 * @param partnerId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiGetAllConfigurationsRequest
 */
func (a *DefaultApiService) GetAllConfigurations(ctx _context.Context, format string, partnerId string, environmentId string, organizationId string) DefaultApiApiGetAllConfigurationsRequest {
	return DefaultApiApiGetAllConfigurationsRequest{
		ApiService: a,
		ctx: ctx,
		format: format,
		partnerId: partnerId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return []map[string]interface{}
 */
func (a *DefaultApiService) GetAllConfigurationsExecute(r DefaultApiApiGetAllConfigurationsRequest) ([]map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetAllConfigurations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partners/{partnerId}/ediFormats/{format}/configurations"
	localVarPath = strings.Replace(localVarPath, "{"+"format"+"}", _neturl.PathEscape(parameterToString(r.format, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partnerId"+"}", _neturl.PathEscape(parameterToString(r.partnerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetAllContactTypesRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	environmentId string
	organizationId string
}


func (r DefaultApiApiGetAllContactTypesRequest) Execute() ([]ContactType, *_nethttp.Response, error) {
	return r.ApiService.GetAllContactTypesExecute(r)
}

/*
 * GetAllContactTypes Method for GetAllContactTypes
 * Get List of supported contact types
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiGetAllContactTypesRequest
 */
func (a *DefaultApiService) GetAllContactTypes(ctx _context.Context, environmentId string, organizationId string) DefaultApiApiGetAllContactTypesRequest {
	return DefaultApiApiGetAllContactTypesRequest{
		ApiService: a,
		ctx: ctx,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return []ContactType
 */
func (a *DefaultApiService) GetAllContactTypesExecute(r DefaultApiApiGetAllContactTypesRequest) ([]ContactType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ContactType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetAllContactTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/contactTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetAllContactsRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	partnerId string
	environmentId string
	organizationId string
}


func (r DefaultApiApiGetAllContactsRequest) Execute() ([]Contact, *_nethttp.Response, error) {
	return r.ApiService.GetAllContactsExecute(r)
}

/*
 * GetAllContacts Method for GetAllContacts
 * Get all contacts
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param partnerId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiGetAllContactsRequest
 */
func (a *DefaultApiService) GetAllContacts(ctx _context.Context, partnerId string, environmentId string, organizationId string) DefaultApiApiGetAllContactsRequest {
	return DefaultApiApiGetAllContactsRequest{
		ApiService: a,
		ctx: ctx,
		partnerId: partnerId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return []Contact
 */
func (a *DefaultApiService) GetAllContactsExecute(r DefaultApiApiGetAllContactsRequest) ([]Contact, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Contact
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetAllContacts")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partners/{partnerId}/contacts"
	localVarPath = strings.Replace(localVarPath, "{"+"partnerId"+"}", _neturl.PathEscape(parameterToString(r.partnerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetAllDocumentflowsRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	environmentId string
	organizationId string
	searchString *string
	name *string
	description *string
	page *int32
	pageSize *int32
}

func (r DefaultApiApiGetAllDocumentflowsRequest) SearchString(searchString string) DefaultApiApiGetAllDocumentflowsRequest {
	r.searchString = &searchString
	return r
}
func (r DefaultApiApiGetAllDocumentflowsRequest) Name(name string) DefaultApiApiGetAllDocumentflowsRequest {
	r.name = &name
	return r
}
func (r DefaultApiApiGetAllDocumentflowsRequest) Description(description string) DefaultApiApiGetAllDocumentflowsRequest {
	r.description = &description
	return r
}
func (r DefaultApiApiGetAllDocumentflowsRequest) Page(page int32) DefaultApiApiGetAllDocumentflowsRequest {
	r.page = &page
	return r
}
func (r DefaultApiApiGetAllDocumentflowsRequest) PageSize(pageSize int32) DefaultApiApiGetAllDocumentflowsRequest {
	r.pageSize = &pageSize
	return r
}

func (r DefaultApiApiGetAllDocumentflowsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetAllDocumentflowsExecute(r)
}

/*
 * GetAllDocumentflows Method for GetAllDocumentflows
 * Get all documents
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiGetAllDocumentflowsRequest
 */
func (a *DefaultApiService) GetAllDocumentflows(ctx _context.Context, environmentId string, organizationId string) DefaultApiApiGetAllDocumentflowsRequest {
	return DefaultApiApiGetAllDocumentflowsRequest{
		ApiService: a,
		ctx: ctx,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) GetAllDocumentflowsExecute(r DefaultApiApiGetAllDocumentflowsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetAllDocumentflows")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/documentflows"
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.searchString != nil {
		localVarQueryParams.Add("searchString", parameterToString(*r.searchString, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.description != nil {
		localVarQueryParams.Add("description", parameterToString(*r.description, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultApiApiGetAllDocumentsRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	partnerId string
	environmentId string
	organizationId string
}


func (r DefaultApiApiGetAllDocumentsRequest) Execute() ([]Document, *_nethttp.Response, error) {
	return r.ApiService.GetAllDocumentsExecute(r)
}

/*
 * GetAllDocuments Method for GetAllDocuments
 * Get all documents
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param partnerId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiGetAllDocumentsRequest
 */
func (a *DefaultApiService) GetAllDocuments(ctx _context.Context, partnerId string, environmentId string, organizationId string) DefaultApiApiGetAllDocumentsRequest {
	return DefaultApiApiGetAllDocumentsRequest{
		ApiService: a,
		ctx: ctx,
		partnerId: partnerId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return []Document
 */
func (a *DefaultApiService) GetAllDocumentsExecute(r DefaultApiApiGetAllDocumentsRequest) ([]Document, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Document
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetAllDocuments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partners/{partnerId}/documents"
	localVarPath = strings.Replace(localVarPath, "{"+"partnerId"+"}", _neturl.PathEscape(parameterToString(r.partnerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetAllEdiDocumentTypesRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	versionId string
	format EdiFormatTypes
	environmentId string
	organizationId string
}


func (r DefaultApiApiGetAllEdiDocumentTypesRequest) Execute() ([]EdiDocumentType, *_nethttp.Response, error) {
	return r.ApiService.GetAllEdiDocumentTypesExecute(r)
}

/*
 * GetAllEdiDocumentTypes Method for GetAllEdiDocumentTypes
 * Get all ediDocumentTypes
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param versionId
 * @param format
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiGetAllEdiDocumentTypesRequest
 */
func (a *DefaultApiService) GetAllEdiDocumentTypes(ctx _context.Context, versionId string, format EdiFormatTypes, environmentId string, organizationId string) DefaultApiApiGetAllEdiDocumentTypesRequest {
	return DefaultApiApiGetAllEdiDocumentTypesRequest{
		ApiService: a,
		ctx: ctx,
		versionId: versionId,
		format: format,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return []EdiDocumentType
 */
func (a *DefaultApiService) GetAllEdiDocumentTypesExecute(r DefaultApiApiGetAllEdiDocumentTypesRequest) ([]EdiDocumentType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []EdiDocumentType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetAllEdiDocumentTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/ediFormats/{format}/ediFormatVersions/{versionId}/ediDocumentTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"versionId"+"}", _neturl.PathEscape(parameterToString(r.versionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"format"+"}", _neturl.PathEscape(parameterToString(r.format, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetAllEdiFormatVersionsRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	format EdiFormatTypes
	environmentId string
	organizationId string
}


func (r DefaultApiApiGetAllEdiFormatVersionsRequest) Execute() ([]EdiFormatVersion, *_nethttp.Response, error) {
	return r.ApiService.GetAllEdiFormatVersionsExecute(r)
}

/*
 * GetAllEdiFormatVersions Method for GetAllEdiFormatVersions
 * Get all ediFormatVersions
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param format
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiGetAllEdiFormatVersionsRequest
 */
func (a *DefaultApiService) GetAllEdiFormatVersions(ctx _context.Context, format EdiFormatTypes, environmentId string, organizationId string) DefaultApiApiGetAllEdiFormatVersionsRequest {
	return DefaultApiApiGetAllEdiFormatVersionsRequest{
		ApiService: a,
		ctx: ctx,
		format: format,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return []EdiFormatVersion
 */
func (a *DefaultApiService) GetAllEdiFormatVersionsExecute(r DefaultApiApiGetAllEdiFormatVersionsRequest) ([]EdiFormatVersion, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []EdiFormatVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetAllEdiFormatVersions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/ediFormats/{format}/ediFormatVersions"
	localVarPath = strings.Replace(localVarPath, "{"+"format"+"}", _neturl.PathEscape(parameterToString(r.format, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetAllEdiFormatsRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	environmentId string
	organizationId string
}


func (r DefaultApiApiGetAllEdiFormatsRequest) Execute() ([]EdiFormat, *_nethttp.Response, error) {
	return r.ApiService.GetAllEdiFormatsExecute(r)
}

/*
 * GetAllEdiFormats Method for GetAllEdiFormats
 * Get all ediFormats
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiGetAllEdiFormatsRequest
 */
func (a *DefaultApiService) GetAllEdiFormats(ctx _context.Context, environmentId string, organizationId string) DefaultApiApiGetAllEdiFormatsRequest {
	return DefaultApiApiGetAllEdiFormatsRequest{
		ApiService: a,
		ctx: ctx,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return []EdiFormat
 */
func (a *DefaultApiService) GetAllEdiFormatsExecute(r DefaultApiApiGetAllEdiFormatsRequest) ([]EdiFormat, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []EdiFormat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetAllEdiFormats")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/ediFormats"
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetAllEndpointsRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	environmentId string
	organizationId string
	partnerId *string
	typeId *string
	role *EndpointRoleType
	deploymentId *string
	deploymentStatus *string
}

func (r DefaultApiApiGetAllEndpointsRequest) PartnerId(partnerId string) DefaultApiApiGetAllEndpointsRequest {
	r.partnerId = &partnerId
	return r
}
func (r DefaultApiApiGetAllEndpointsRequest) TypeId(typeId string) DefaultApiApiGetAllEndpointsRequest {
	r.typeId = &typeId
	return r
}
func (r DefaultApiApiGetAllEndpointsRequest) Role(role EndpointRoleType) DefaultApiApiGetAllEndpointsRequest {
	r.role = &role
	return r
}
func (r DefaultApiApiGetAllEndpointsRequest) DeploymentId(deploymentId string) DefaultApiApiGetAllEndpointsRequest {
	r.deploymentId = &deploymentId
	return r
}
func (r DefaultApiApiGetAllEndpointsRequest) DeploymentStatus(deploymentStatus string) DefaultApiApiGetAllEndpointsRequest {
	r.deploymentStatus = &deploymentStatus
	return r
}

func (r DefaultApiApiGetAllEndpointsRequest) Execute() ([]map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.GetAllEndpointsExecute(r)
}

/*
 * GetAllEndpoints Method for GetAllEndpoints
 * Get endpoints
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiGetAllEndpointsRequest
 */
func (a *DefaultApiService) GetAllEndpoints(ctx _context.Context, environmentId string, organizationId string) DefaultApiApiGetAllEndpointsRequest {
	return DefaultApiApiGetAllEndpointsRequest{
		ApiService: a,
		ctx: ctx,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return []map[string]interface{}
 */
func (a *DefaultApiService) GetAllEndpointsExecute(r DefaultApiApiGetAllEndpointsRequest) ([]map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetAllEndpoints")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/endpoints"
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	if r.typeId != nil {
		localVarQueryParams.Add("typeId", parameterToString(*r.typeId, ""))
	}
	if r.role != nil {
		localVarQueryParams.Add("role", parameterToString(*r.role, ""))
	}
	if r.deploymentId != nil {
		localVarQueryParams.Add("deploymentId", parameterToString(*r.deploymentId, ""))
	}
	if r.deploymentStatus != nil {
		localVarQueryParams.Add("deploymentStatus", parameterToString(*r.deploymentStatus, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetAllIdentifierTypesRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	environmentId string
	organizationId string
}


func (r DefaultApiApiGetAllIdentifierTypesRequest) Execute() ([]IdentifierType, *_nethttp.Response, error) {
	return r.ApiService.GetAllIdentifierTypesExecute(r)
}

/*
 * GetAllIdentifierTypes Method for GetAllIdentifierTypes
 * Get all identifierTypes
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiGetAllIdentifierTypesRequest
 */
func (a *DefaultApiService) GetAllIdentifierTypes(ctx _context.Context, environmentId string, organizationId string) DefaultApiApiGetAllIdentifierTypesRequest {
	return DefaultApiApiGetAllIdentifierTypesRequest{
		ApiService: a,
		ctx: ctx,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return []IdentifierType
 */
func (a *DefaultApiService) GetAllIdentifierTypesExecute(r DefaultApiApiGetAllIdentifierTypesRequest) ([]IdentifierType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []IdentifierType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetAllIdentifierTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/identifierTypes"
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetAllIdentifiersRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	partnerId string
	environmentId string
	organizationId string
}


func (r DefaultApiApiGetAllIdentifiersRequest) Execute() ([]Identifier, *_nethttp.Response, error) {
	return r.ApiService.GetAllIdentifiersExecute(r)
}

/*
 * GetAllIdentifiers Method for GetAllIdentifiers
 * Get all identifiers
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param partnerId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiGetAllIdentifiersRequest
 */
func (a *DefaultApiService) GetAllIdentifiers(ctx _context.Context, partnerId string, environmentId string, organizationId string) DefaultApiApiGetAllIdentifiersRequest {
	return DefaultApiApiGetAllIdentifiersRequest{
		ApiService: a,
		ctx: ctx,
		partnerId: partnerId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return []Identifier
 */
func (a *DefaultApiService) GetAllIdentifiersExecute(r DefaultApiApiGetAllIdentifiersRequest) ([]Identifier, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Identifier
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetAllIdentifiers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partners/{partnerId}/identifiers"
	localVarPath = strings.Replace(localVarPath, "{"+"partnerId"+"}", _neturl.PathEscape(parameterToString(r.partnerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetAllMappingsRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	documentflowId string
	environmentId string
	organizationId string
}


func (r DefaultApiApiGetAllMappingsRequest) Execute() ([]DocumentMappingConfig, *_nethttp.Response, error) {
	return r.ApiService.GetAllMappingsExecute(r)
}

/*
 * GetAllMappings Method for GetAllMappings
 * Get all mappings
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param documentflowId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiGetAllMappingsRequest
 */
func (a *DefaultApiService) GetAllMappings(ctx _context.Context, documentflowId string, environmentId string, organizationId string) DefaultApiApiGetAllMappingsRequest {
	return DefaultApiApiGetAllMappingsRequest{
		ApiService: a,
		ctx: ctx,
		documentflowId: documentflowId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return []DocumentMappingConfig
 */
func (a *DefaultApiService) GetAllMappingsExecute(r DefaultApiApiGetAllMappingsRequest) ([]DocumentMappingConfig, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []DocumentMappingConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetAllMappings")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/documentflows/{documentflowId}/mappings"
	localVarPath = strings.Replace(localVarPath, "{"+"documentflowId"+"}", _neturl.PathEscape(parameterToString(r.documentflowId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetAllPartnerProfilesRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	environmentId string
	organizationId string
}


func (r DefaultApiApiGetAllPartnerProfilesRequest) Execute() ([]Partnerprofile, *_nethttp.Response, error) {
	return r.ApiService.GetAllPartnerProfilesExecute(r)
}

/*
 * GetAllPartnerProfiles Method for GetAllPartnerProfiles
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiGetAllPartnerProfilesRequest
 */
func (a *DefaultApiService) GetAllPartnerProfiles(ctx _context.Context, environmentId string, organizationId string) DefaultApiApiGetAllPartnerProfilesRequest {
	return DefaultApiApiGetAllPartnerProfilesRequest{
		ApiService: a,
		ctx: ctx,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return []Partnerprofile
 */
func (a *DefaultApiService) GetAllPartnerProfilesExecute(r DefaultApiApiGetAllPartnerProfilesRequest) ([]Partnerprofile, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Partnerprofile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetAllPartnerProfiles")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partnerprofiles"
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetAllPartnersRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	environmentId string
	organizationId string
}


func (r DefaultApiApiGetAllPartnersRequest) Execute() ([]Partner, *_nethttp.Response, error) {
	return r.ApiService.GetAllPartnersExecute(r)
}

/*
 * GetAllPartners Method for GetAllPartners
 * Get all partners
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiGetAllPartnersRequest
 */
func (a *DefaultApiService) GetAllPartners(ctx _context.Context, environmentId string, organizationId string) DefaultApiApiGetAllPartnersRequest {
	return DefaultApiApiGetAllPartnersRequest{
		ApiService: a,
		ctx: ctx,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return []Partner
 */
func (a *DefaultApiService) GetAllPartnersExecute(r DefaultApiApiGetAllPartnersRequest) ([]Partner, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Partner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetAllPartners")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partners"
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetConfigurationRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	configId string
	format string
	partnerId string
	environmentId string
	organizationId string
}


func (r DefaultApiApiGetConfigurationRequest) Execute() (EdiFormatConfiguration, *_nethttp.Response, error) {
	return r.ApiService.GetConfigurationExecute(r)
}

/*
 * GetConfiguration Method for GetConfiguration
 * Get Configuration
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param configId
 * @param format
 * @param partnerId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiGetConfigurationRequest
 */
func (a *DefaultApiService) GetConfiguration(ctx _context.Context, configId string, format string, partnerId string, environmentId string, organizationId string) DefaultApiApiGetConfigurationRequest {
	return DefaultApiApiGetConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		configId: configId,
		format: format,
		partnerId: partnerId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return EdiFormatConfiguration
 */
func (a *DefaultApiService) GetConfigurationExecute(r DefaultApiApiGetConfigurationRequest) (EdiFormatConfiguration, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  EdiFormatConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetConfiguration")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partners/{partnerId}/ediFormats/{format}/configurations/{configId}"
	localVarPath = strings.Replace(localVarPath, "{"+"configId"+"}", _neturl.PathEscape(parameterToString(r.configId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"format"+"}", _neturl.PathEscape(parameterToString(r.format, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partnerId"+"}", _neturl.PathEscape(parameterToString(r.partnerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetContactRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	contactId string
	partnerId string
	environmentId string
	organizationId string
}


func (r DefaultApiApiGetContactRequest) Execute() (Contact, *_nethttp.Response, error) {
	return r.ApiService.GetContactExecute(r)
}

/*
 * GetContact Method for GetContact
 * Get Contact
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param contactId
 * @param partnerId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiGetContactRequest
 */
func (a *DefaultApiService) GetContact(ctx _context.Context, contactId string, partnerId string, environmentId string, organizationId string) DefaultApiApiGetContactRequest {
	return DefaultApiApiGetContactRequest{
		ApiService: a,
		ctx: ctx,
		contactId: contactId,
		partnerId: partnerId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return Contact
 */
func (a *DefaultApiService) GetContactExecute(r DefaultApiApiGetContactRequest) (Contact, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Contact
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetContact")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partners/{partnerId}/contacts/{contactId}"
	localVarPath = strings.Replace(localVarPath, "{"+"contactId"+"}", _neturl.PathEscape(parameterToString(r.contactId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partnerId"+"}", _neturl.PathEscape(parameterToString(r.partnerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetCustomAttributeRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	customAttributeId string
	environmentId string
	organizationId string
}


func (r DefaultApiApiGetCustomAttributeRequest) Execute() (CustomAttribute, *_nethttp.Response, error) {
	return r.ApiService.GetCustomAttributeExecute(r)
}

/*
 * GetCustomAttribute Method for GetCustomAttribute
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param customAttributeId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiGetCustomAttributeRequest
 */
func (a *DefaultApiService) GetCustomAttribute(ctx _context.Context, customAttributeId string, environmentId string, organizationId string) DefaultApiApiGetCustomAttributeRequest {
	return DefaultApiApiGetCustomAttributeRequest{
		ApiService: a,
		ctx: ctx,
		customAttributeId: customAttributeId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return CustomAttribute
 */
func (a *DefaultApiService) GetCustomAttributeExecute(r DefaultApiApiGetCustomAttributeRequest) (CustomAttribute, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CustomAttribute
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetCustomAttribute")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/customAttributes/{customAttributeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"customAttributeId"+"}", _neturl.PathEscape(parameterToString(r.customAttributeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetDeploymentRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	deploymentId string
	environmentId string
	organizationId string
}


func (r DefaultApiApiGetDeploymentRequest) Execute() (DocumentFlowConfigInstance, *_nethttp.Response, error) {
	return r.ApiService.GetDeploymentExecute(r)
}

/*
 * GetDeployment Method for GetDeployment
 * Get deployments
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param deploymentId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiGetDeploymentRequest
 */
func (a *DefaultApiService) GetDeployment(ctx _context.Context, deploymentId string, environmentId string, organizationId string) DefaultApiApiGetDeploymentRequest {
	return DefaultApiApiGetDeploymentRequest{
		ApiService: a,
		ctx: ctx,
		deploymentId: deploymentId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return DocumentFlowConfigInstance
 */
func (a *DefaultApiService) GetDeploymentExecute(r DefaultApiApiGetDeploymentRequest) (DocumentFlowConfigInstance, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DocumentFlowConfigInstance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetDeployment")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/deployments/{deploymentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deploymentId"+"}", _neturl.PathEscape(parameterToString(r.deploymentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetDeploymentConfigurationsRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	environmentId string
	organizationId string
	fromPartner *string
	toPartner *string
	formatType *string
	formatVersion *string
	docType *string
	receivingEndpointId *string
	status *string
}

func (r DefaultApiApiGetDeploymentConfigurationsRequest) FromPartner(fromPartner string) DefaultApiApiGetDeploymentConfigurationsRequest {
	r.fromPartner = &fromPartner
	return r
}
func (r DefaultApiApiGetDeploymentConfigurationsRequest) ToPartner(toPartner string) DefaultApiApiGetDeploymentConfigurationsRequest {
	r.toPartner = &toPartner
	return r
}
func (r DefaultApiApiGetDeploymentConfigurationsRequest) FormatType(formatType string) DefaultApiApiGetDeploymentConfigurationsRequest {
	r.formatType = &formatType
	return r
}
func (r DefaultApiApiGetDeploymentConfigurationsRequest) FormatVersion(formatVersion string) DefaultApiApiGetDeploymentConfigurationsRequest {
	r.formatVersion = &formatVersion
	return r
}
func (r DefaultApiApiGetDeploymentConfigurationsRequest) DocType(docType string) DefaultApiApiGetDeploymentConfigurationsRequest {
	r.docType = &docType
	return r
}
func (r DefaultApiApiGetDeploymentConfigurationsRequest) ReceivingEndpointId(receivingEndpointId string) DefaultApiApiGetDeploymentConfigurationsRequest {
	r.receivingEndpointId = &receivingEndpointId
	return r
}
func (r DefaultApiApiGetDeploymentConfigurationsRequest) Status(status string) DefaultApiApiGetDeploymentConfigurationsRequest {
	r.status = &status
	return r
}

func (r DefaultApiApiGetDeploymentConfigurationsRequest) Execute() ([]DocumentFlowConfigInstance, *_nethttp.Response, error) {
	return r.ApiService.GetDeploymentConfigurationsExecute(r)
}

/*
 * GetDeploymentConfigurations Method for GetDeploymentConfigurations
 * Get Deployment configurations
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiGetDeploymentConfigurationsRequest
 */
func (a *DefaultApiService) GetDeploymentConfigurations(ctx _context.Context, environmentId string, organizationId string) DefaultApiApiGetDeploymentConfigurationsRequest {
	return DefaultApiApiGetDeploymentConfigurationsRequest{
		ApiService: a,
		ctx: ctx,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return []DocumentFlowConfigInstance
 */
func (a *DefaultApiService) GetDeploymentConfigurationsExecute(r DefaultApiApiGetDeploymentConfigurationsRequest) ([]DocumentFlowConfigInstance, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []DocumentFlowConfigInstance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetDeploymentConfigurations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/deployments"
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fromPartner != nil {
		localVarQueryParams.Add("fromPartner", parameterToString(*r.fromPartner, ""))
	}
	if r.toPartner != nil {
		localVarQueryParams.Add("toPartner", parameterToString(*r.toPartner, ""))
	}
	if r.formatType != nil {
		localVarQueryParams.Add("formatType", parameterToString(*r.formatType, ""))
	}
	if r.formatVersion != nil {
		localVarQueryParams.Add("formatVersion", parameterToString(*r.formatVersion, ""))
	}
	if r.docType != nil {
		localVarQueryParams.Add("docType", parameterToString(*r.docType, ""))
	}
	if r.receivingEndpointId != nil {
		localVarQueryParams.Add("receivingEndpointId", parameterToString(*r.receivingEndpointId, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetDocumentRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	documentById string
	partnerId string
	environmentId string
	organizationId string
}


func (r DefaultApiApiGetDocumentRequest) Execute() (Document, *_nethttp.Response, error) {
	return r.ApiService.GetDocumentExecute(r)
}

/*
 * GetDocument Method for GetDocument
 * Get Document
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param documentById
 * @param partnerId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiGetDocumentRequest
 */
func (a *DefaultApiService) GetDocument(ctx _context.Context, documentById string, partnerId string, environmentId string, organizationId string) DefaultApiApiGetDocumentRequest {
	return DefaultApiApiGetDocumentRequest{
		ApiService: a,
		ctx: ctx,
		documentById: documentById,
		partnerId: partnerId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return Document
 */
func (a *DefaultApiService) GetDocumentExecute(r DefaultApiApiGetDocumentRequest) (Document, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Document
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetDocument")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partners/{partnerId}/documents/{documentById}"
	localVarPath = strings.Replace(localVarPath, "{"+"documentById"+"}", _neturl.PathEscape(parameterToString(r.documentById, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partnerId"+"}", _neturl.PathEscape(parameterToString(r.partnerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetDocumentflowRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	documentflowId string
	environmentId string
	organizationId string
}


func (r DefaultApiApiGetDocumentflowRequest) Execute() (DocumentFlow, *_nethttp.Response, error) {
	return r.ApiService.GetDocumentflowExecute(r)
}

/*
 * GetDocumentflow Method for GetDocumentflow
 * Get Documentflow
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param documentflowId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiGetDocumentflowRequest
 */
func (a *DefaultApiService) GetDocumentflow(ctx _context.Context, documentflowId string, environmentId string, organizationId string) DefaultApiApiGetDocumentflowRequest {
	return DefaultApiApiGetDocumentflowRequest{
		ApiService: a,
		ctx: ctx,
		documentflowId: documentflowId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return DocumentFlow
 */
func (a *DefaultApiService) GetDocumentflowExecute(r DefaultApiApiGetDocumentflowRequest) (DocumentFlow, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DocumentFlow
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetDocumentflow")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/documentflows/{documentflowId}"
	localVarPath = strings.Replace(localVarPath, "{"+"documentflowId"+"}", _neturl.PathEscape(parameterToString(r.documentflowId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetEdiFormatRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	format EdiFormatTypes
	environmentId string
	organizationId string
}


func (r DefaultApiApiGetEdiFormatRequest) Execute() (EdiFormat, *_nethttp.Response, error) {
	return r.ApiService.GetEdiFormatExecute(r)
}

/*
 * GetEdiFormat Method for GetEdiFormat
 * Get ediFormats
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param format
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiGetEdiFormatRequest
 */
func (a *DefaultApiService) GetEdiFormat(ctx _context.Context, format EdiFormatTypes, environmentId string, organizationId string) DefaultApiApiGetEdiFormatRequest {
	return DefaultApiApiGetEdiFormatRequest{
		ApiService: a,
		ctx: ctx,
		format: format,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return EdiFormat
 */
func (a *DefaultApiService) GetEdiFormatExecute(r DefaultApiApiGetEdiFormatRequest) (EdiFormat, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  EdiFormat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetEdiFormat")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/ediFormats/{format}"
	localVarPath = strings.Replace(localVarPath, "{"+"format"+"}", _neturl.PathEscape(parameterToString(r.format, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetEdiFormatDocumentRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	docId string
	format string
	partnerId string
	environmentId string
	organizationId string
}


func (r DefaultApiApiGetEdiFormatDocumentRequest) Execute() (interface{}, *_nethttp.Response, error) {
	return r.ApiService.GetEdiFormatDocumentExecute(r)
}

/*
 * GetEdiFormatDocument Method for GetEdiFormatDocument
 * Get Document
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param docId
 * @param format
 * @param partnerId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiGetEdiFormatDocumentRequest
 */
func (a *DefaultApiService) GetEdiFormatDocument(ctx _context.Context, docId string, format string, partnerId string, environmentId string, organizationId string) DefaultApiApiGetEdiFormatDocumentRequest {
	return DefaultApiApiGetEdiFormatDocumentRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		format: format,
		partnerId: partnerId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return interface{}
 */
func (a *DefaultApiService) GetEdiFormatDocumentExecute(r DefaultApiApiGetEdiFormatDocumentRequest) (interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetEdiFormatDocument")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partners/{partnerId}/ediFormats/{format}/documents/{docId}"
	localVarPath = strings.Replace(localVarPath, "{"+"docId"+"}", _neturl.PathEscape(parameterToString(r.docId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"format"+"}", _neturl.PathEscape(parameterToString(r.format, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partnerId"+"}", _neturl.PathEscape(parameterToString(r.partnerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetEdiFormatDocumentsRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	format string
	partnerId string
	environmentId string
	organizationId string
}


func (r DefaultApiApiGetEdiFormatDocumentsRequest) Execute() ([]map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.GetEdiFormatDocumentsExecute(r)
}

/*
 * GetEdiFormatDocuments Method for GetEdiFormatDocuments
 * Get all documents
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param format
 * @param partnerId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiGetEdiFormatDocumentsRequest
 */
func (a *DefaultApiService) GetEdiFormatDocuments(ctx _context.Context, format string, partnerId string, environmentId string, organizationId string) DefaultApiApiGetEdiFormatDocumentsRequest {
	return DefaultApiApiGetEdiFormatDocumentsRequest{
		ApiService: a,
		ctx: ctx,
		format: format,
		partnerId: partnerId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return []map[string]interface{}
 */
func (a *DefaultApiService) GetEdiFormatDocumentsExecute(r DefaultApiApiGetEdiFormatDocumentsRequest) ([]map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetEdiFormatDocuments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partners/{partnerId}/ediFormats/{format}/documents"
	localVarPath = strings.Replace(localVarPath, "{"+"format"+"}", _neturl.PathEscape(parameterToString(r.format, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partnerId"+"}", _neturl.PathEscape(parameterToString(r.partnerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetEdiFormatVersionRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	versionId string
	format EdiFormatTypes
	environmentId string
	organizationId string
}


func (r DefaultApiApiGetEdiFormatVersionRequest) Execute() (EdiFormatVersion, *_nethttp.Response, error) {
	return r.ApiService.GetEdiFormatVersionExecute(r)
}

/*
 * GetEdiFormatVersion Method for GetEdiFormatVersion
 * Get ediFormatVersions
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param versionId
 * @param format
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiGetEdiFormatVersionRequest
 */
func (a *DefaultApiService) GetEdiFormatVersion(ctx _context.Context, versionId string, format EdiFormatTypes, environmentId string, organizationId string) DefaultApiApiGetEdiFormatVersionRequest {
	return DefaultApiApiGetEdiFormatVersionRequest{
		ApiService: a,
		ctx: ctx,
		versionId: versionId,
		format: format,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return EdiFormatVersion
 */
func (a *DefaultApiService) GetEdiFormatVersionExecute(r DefaultApiApiGetEdiFormatVersionRequest) (EdiFormatVersion, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  EdiFormatVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetEdiFormatVersion")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/ediFormats/{format}/ediFormatVersions/{versionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"versionId"+"}", _neturl.PathEscape(parameterToString(r.versionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"format"+"}", _neturl.PathEscape(parameterToString(r.format, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetEndpointRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	endpointId string
	environmentId string
	organizationId string
}


func (r DefaultApiApiGetEndpointRequest) Execute() (Endpoint, *_nethttp.Response, error) {
	return r.ApiService.GetEndpointExecute(r)
}

/*
 * GetEndpoint Method for GetEndpoint
 * Get Endpoint
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param endpointId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiGetEndpointRequest
 */
func (a *DefaultApiService) GetEndpoint(ctx _context.Context, endpointId string, environmentId string, organizationId string) DefaultApiApiGetEndpointRequest {
	return DefaultApiApiGetEndpointRequest{
		ApiService: a,
		ctx: ctx,
		endpointId: endpointId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return Endpoint
 */
func (a *DefaultApiService) GetEndpointExecute(r DefaultApiApiGetEndpointRequest) (Endpoint, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Endpoint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetEndpoint")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/endpoints/{endpointId}"
	localVarPath = strings.Replace(localVarPath, "{"+"endpointId"+"}", _neturl.PathEscape(parameterToString(r.endpointId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetIdentifierRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	identifierId string
	partnerId string
	environmentId string
	organizationId string
}


func (r DefaultApiApiGetIdentifierRequest) Execute() (Identifier, *_nethttp.Response, error) {
	return r.ApiService.GetIdentifierExecute(r)
}

/*
 * GetIdentifier Method for GetIdentifier
 * Get Identifier
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param identifierId
 * @param partnerId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiGetIdentifierRequest
 */
func (a *DefaultApiService) GetIdentifier(ctx _context.Context, identifierId string, partnerId string, environmentId string, organizationId string) DefaultApiApiGetIdentifierRequest {
	return DefaultApiApiGetIdentifierRequest{
		ApiService: a,
		ctx: ctx,
		identifierId: identifierId,
		partnerId: partnerId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return Identifier
 */
func (a *DefaultApiService) GetIdentifierExecute(r DefaultApiApiGetIdentifierRequest) (Identifier, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Identifier
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetIdentifier")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partners/{partnerId}/identifiers/{identifierId}"
	localVarPath = strings.Replace(localVarPath, "{"+"identifierId"+"}", _neturl.PathEscape(parameterToString(r.identifierId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partnerId"+"}", _neturl.PathEscape(parameterToString(r.partnerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetIdentifierTypeRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	identifierTypeId string
	environmentId string
	organizationId string
}


func (r DefaultApiApiGetIdentifierTypeRequest) Execute() (IdentifierType, *_nethttp.Response, error) {
	return r.ApiService.GetIdentifierTypeExecute(r)
}

/*
 * GetIdentifierType Method for GetIdentifierType
 * Get identifierTypes
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param identifierTypeId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiGetIdentifierTypeRequest
 */
func (a *DefaultApiService) GetIdentifierType(ctx _context.Context, identifierTypeId string, environmentId string, organizationId string) DefaultApiApiGetIdentifierTypeRequest {
	return DefaultApiApiGetIdentifierTypeRequest{
		ApiService: a,
		ctx: ctx,
		identifierTypeId: identifierTypeId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return IdentifierType
 */
func (a *DefaultApiService) GetIdentifierTypeExecute(r DefaultApiApiGetIdentifierTypeRequest) (IdentifierType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  IdentifierType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetIdentifierType")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/identifierTypes/{identifierTypeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"identifierTypeId"+"}", _neturl.PathEscape(parameterToString(r.identifierTypeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetMappingRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	mappingsId string
	documentflowId string
	environmentId string
	organizationId string
}


func (r DefaultApiApiGetMappingRequest) Execute() (DocumentMappingConfig, *_nethttp.Response, error) {
	return r.ApiService.GetMappingExecute(r)
}

/*
 * GetMapping Method for GetMapping
 * Get Mapping
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param mappingsId
 * @param documentflowId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiGetMappingRequest
 */
func (a *DefaultApiService) GetMapping(ctx _context.Context, mappingsId string, documentflowId string, environmentId string, organizationId string) DefaultApiApiGetMappingRequest {
	return DefaultApiApiGetMappingRequest{
		ApiService: a,
		ctx: ctx,
		mappingsId: mappingsId,
		documentflowId: documentflowId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return DocumentMappingConfig
 */
func (a *DefaultApiService) GetMappingExecute(r DefaultApiApiGetMappingRequest) (DocumentMappingConfig, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DocumentMappingConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetMapping")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/documentflows/{documentflowId}/mappings/{mappingsId}"
	localVarPath = strings.Replace(localVarPath, "{"+"mappingsId"+"}", _neturl.PathEscape(parameterToString(r.mappingsId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"documentflowId"+"}", _neturl.PathEscape(parameterToString(r.documentflowId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetPartnerRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	partnerId string
	environmentId string
	organizationId string
}


func (r DefaultApiApiGetPartnerRequest) Execute() (Partner, *_nethttp.Response, error) {
	return r.ApiService.GetPartnerExecute(r)
}

/*
 * GetPartner Method for GetPartner
 * Get Partner
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param partnerId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiGetPartnerRequest
 */
func (a *DefaultApiService) GetPartner(ctx _context.Context, partnerId string, environmentId string, organizationId string) DefaultApiApiGetPartnerRequest {
	return DefaultApiApiGetPartnerRequest{
		ApiService: a,
		ctx: ctx,
		partnerId: partnerId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return Partner
 */
func (a *DefaultApiService) GetPartnerExecute(r DefaultApiApiGetPartnerRequest) (Partner, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Partner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetPartner")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partners/{partnerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"partnerId"+"}", _neturl.PathEscape(parameterToString(r.partnerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetPartnerCertificateRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	certificateId string
	partnerId string
	environmentId string
	organizationId string
}


func (r DefaultApiApiGetPartnerCertificateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetPartnerCertificateExecute(r)
}

/*
 * GetPartnerCertificate Method for GetPartnerCertificate
 * Get Certificate
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param certificateId
 * @param partnerId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiGetPartnerCertificateRequest
 */
func (a *DefaultApiService) GetPartnerCertificate(ctx _context.Context, certificateId string, partnerId string, environmentId string, organizationId string) DefaultApiApiGetPartnerCertificateRequest {
	return DefaultApiApiGetPartnerCertificateRequest{
		ApiService: a,
		ctx: ctx,
		certificateId: certificateId,
		partnerId: partnerId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) GetPartnerCertificateExecute(r DefaultApiApiGetPartnerCertificateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetPartnerCertificate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partners/{partnerId}/certificates/{certificateId}"
	localVarPath = strings.Replace(localVarPath, "{"+"certificateId"+"}", _neturl.PathEscape(parameterToString(r.certificateId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partnerId"+"}", _neturl.PathEscape(parameterToString(r.partnerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultApiApiGetPartnerLogoRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	partnerId string
	environmentId string
	organizationId string
}


func (r DefaultApiApiGetPartnerLogoRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetPartnerLogoExecute(r)
}

/*
 * GetPartnerLogo Method for GetPartnerLogo
 * Get Partner Logo
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param partnerId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiGetPartnerLogoRequest
 */
func (a *DefaultApiService) GetPartnerLogo(ctx _context.Context, partnerId string, environmentId string, organizationId string) DefaultApiApiGetPartnerLogoRequest {
	return DefaultApiApiGetPartnerLogoRequest{
		ApiService: a,
		ctx: ctx,
		partnerId: partnerId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) GetPartnerLogoExecute(r DefaultApiApiGetPartnerLogoRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetPartnerLogo")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partners/{partnerId}/logo"
	localVarPath = strings.Replace(localVarPath, "{"+"partnerId"+"}", _neturl.PathEscape(parameterToString(r.partnerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultApiApiGetPartnerProfileRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	partnerId string
	environmentId string
	organizationId string
}


func (r DefaultApiApiGetPartnerProfileRequest) Execute() (Partnerprofile, *_nethttp.Response, error) {
	return r.ApiService.GetPartnerProfileExecute(r)
}

/*
 * GetPartnerProfile Method for GetPartnerProfile
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param partnerId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiGetPartnerProfileRequest
 */
func (a *DefaultApiService) GetPartnerProfile(ctx _context.Context, partnerId string, environmentId string, organizationId string) DefaultApiApiGetPartnerProfileRequest {
	return DefaultApiApiGetPartnerProfileRequest{
		ApiService: a,
		ctx: ctx,
		partnerId: partnerId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return Partnerprofile
 */
func (a *DefaultApiService) GetPartnerProfileExecute(r DefaultApiApiGetPartnerProfileRequest) (Partnerprofile, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Partnerprofile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetPartnerProfile")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partnerprofiles/{partnerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"partnerId"+"}", _neturl.PathEscape(parameterToString(r.partnerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiGetStatusRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	statusId string
	partnerId string
	environmentId string
	organizationId string
}


func (r DefaultApiApiGetStatusRequest) Execute() (TimedStatus, *_nethttp.Response, error) {
	return r.ApiService.GetStatusExecute(r)
}

/*
 * GetStatus Method for GetStatus
 * Get statuses
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param statusId
 * @param partnerId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiGetStatusRequest
 */
func (a *DefaultApiService) GetStatus(ctx _context.Context, statusId string, partnerId string, environmentId string, organizationId string) DefaultApiApiGetStatusRequest {
	return DefaultApiApiGetStatusRequest{
		ApiService: a,
		ctx: ctx,
		statusId: statusId,
		partnerId: partnerId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 * @return TimedStatus
 */
func (a *DefaultApiService) GetStatusExecute(r DefaultApiApiGetStatusRequest) (TimedStatus, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TimedStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetStatus")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partners/{partnerId}/statuses/{statusId}"
	localVarPath = strings.Replace(localVarPath, "{"+"statusId"+"}", _neturl.PathEscape(parameterToString(r.statusId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partnerId"+"}", _neturl.PathEscape(parameterToString(r.partnerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiApiReplaceConfigurationRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	configId string
	format string
	partnerId string
	environmentId string
	organizationId string
	ediFormatConfiguration *EdiFormatConfiguration
}

func (r DefaultApiApiReplaceConfigurationRequest) EdiFormatConfiguration(ediFormatConfiguration EdiFormatConfiguration) DefaultApiApiReplaceConfigurationRequest {
	r.ediFormatConfiguration = &ediFormatConfiguration
	return r
}

func (r DefaultApiApiReplaceConfigurationRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ReplaceConfigurationExecute(r)
}

/*
 * ReplaceConfiguration Method for ReplaceConfiguration
 * Replace configuration
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param configId
 * @param format
 * @param partnerId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiReplaceConfigurationRequest
 */
func (a *DefaultApiService) ReplaceConfiguration(ctx _context.Context, configId string, format string, partnerId string, environmentId string, organizationId string) DefaultApiApiReplaceConfigurationRequest {
	return DefaultApiApiReplaceConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		configId: configId,
		format: format,
		partnerId: partnerId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ReplaceConfigurationExecute(r DefaultApiApiReplaceConfigurationRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ReplaceConfiguration")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partners/{partnerId}/ediFormats/{format}/configurations/{configId}"
	localVarPath = strings.Replace(localVarPath, "{"+"configId"+"}", _neturl.PathEscape(parameterToString(r.configId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"format"+"}", _neturl.PathEscape(parameterToString(r.format, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partnerId"+"}", _neturl.PathEscape(parameterToString(r.partnerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.ediFormatConfiguration == nil {
		return nil, reportError("ediFormatConfiguration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.ediFormatConfiguration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultApiApiReplaceContactRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	contactId string
	partnerId string
	environmentId string
	organizationId string
	contact *Contact
}

func (r DefaultApiApiReplaceContactRequest) Contact(contact Contact) DefaultApiApiReplaceContactRequest {
	r.contact = &contact
	return r
}

func (r DefaultApiApiReplaceContactRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ReplaceContactExecute(r)
}

/*
 * ReplaceContact Method for ReplaceContact
 * Replace contact
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param contactId
 * @param partnerId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiReplaceContactRequest
 */
func (a *DefaultApiService) ReplaceContact(ctx _context.Context, contactId string, partnerId string, environmentId string, organizationId string) DefaultApiApiReplaceContactRequest {
	return DefaultApiApiReplaceContactRequest{
		ApiService: a,
		ctx: ctx,
		contactId: contactId,
		partnerId: partnerId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ReplaceContactExecute(r DefaultApiApiReplaceContactRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ReplaceContact")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partners/{partnerId}/contacts/{contactId}"
	localVarPath = strings.Replace(localVarPath, "{"+"contactId"+"}", _neturl.PathEscape(parameterToString(r.contactId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partnerId"+"}", _neturl.PathEscape(parameterToString(r.partnerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.contact == nil {
		return nil, reportError("contact is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.contact
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultApiApiReplaceDocumentRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	documentById string
	partnerId string
	environmentId string
	organizationId string
	document *Document
}

func (r DefaultApiApiReplaceDocumentRequest) Document(document Document) DefaultApiApiReplaceDocumentRequest {
	r.document = &document
	return r
}

func (r DefaultApiApiReplaceDocumentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ReplaceDocumentExecute(r)
}

/*
 * ReplaceDocument Method for ReplaceDocument
 * Replace document
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param documentById
 * @param partnerId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiReplaceDocumentRequest
 */
func (a *DefaultApiService) ReplaceDocument(ctx _context.Context, documentById string, partnerId string, environmentId string, organizationId string) DefaultApiApiReplaceDocumentRequest {
	return DefaultApiApiReplaceDocumentRequest{
		ApiService: a,
		ctx: ctx,
		documentById: documentById,
		partnerId: partnerId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ReplaceDocumentExecute(r DefaultApiApiReplaceDocumentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ReplaceDocument")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partners/{partnerId}/documents/{documentById}"
	localVarPath = strings.Replace(localVarPath, "{"+"documentById"+"}", _neturl.PathEscape(parameterToString(r.documentById, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partnerId"+"}", _neturl.PathEscape(parameterToString(r.partnerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.document == nil {
		return nil, reportError("document is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.document
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultApiApiReplaceDocumentflowRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	documentflowId string
	environmentId string
	organizationId string
	documentFlow *DocumentFlow
}

func (r DefaultApiApiReplaceDocumentflowRequest) DocumentFlow(documentFlow DocumentFlow) DefaultApiApiReplaceDocumentflowRequest {
	r.documentFlow = &documentFlow
	return r
}

func (r DefaultApiApiReplaceDocumentflowRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ReplaceDocumentflowExecute(r)
}

/*
 * ReplaceDocumentflow Method for ReplaceDocumentflow
 * Replace documentflow
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param documentflowId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiReplaceDocumentflowRequest
 */
func (a *DefaultApiService) ReplaceDocumentflow(ctx _context.Context, documentflowId string, environmentId string, organizationId string) DefaultApiApiReplaceDocumentflowRequest {
	return DefaultApiApiReplaceDocumentflowRequest{
		ApiService: a,
		ctx: ctx,
		documentflowId: documentflowId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ReplaceDocumentflowExecute(r DefaultApiApiReplaceDocumentflowRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ReplaceDocumentflow")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/documentflows/{documentflowId}"
	localVarPath = strings.Replace(localVarPath, "{"+"documentflowId"+"}", _neturl.PathEscape(parameterToString(r.documentflowId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.documentFlow == nil {
		return nil, reportError("documentFlow is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.documentFlow
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultApiApiReplaceEdiFormatDocumentRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	docId string
	format string
	partnerId string
	environmentId string
	organizationId string
	body *map[string]interface{}
}

func (r DefaultApiApiReplaceEdiFormatDocumentRequest) Body(body map[string]interface{}) DefaultApiApiReplaceEdiFormatDocumentRequest {
	r.body = &body
	return r
}

func (r DefaultApiApiReplaceEdiFormatDocumentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ReplaceEdiFormatDocumentExecute(r)
}

/*
 * ReplaceEdiFormatDocument Method for ReplaceEdiFormatDocument
 * Replace document
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param docId
 * @param format
 * @param partnerId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiReplaceEdiFormatDocumentRequest
 */
func (a *DefaultApiService) ReplaceEdiFormatDocument(ctx _context.Context, docId string, format string, partnerId string, environmentId string, organizationId string) DefaultApiApiReplaceEdiFormatDocumentRequest {
	return DefaultApiApiReplaceEdiFormatDocumentRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		format: format,
		partnerId: partnerId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ReplaceEdiFormatDocumentExecute(r DefaultApiApiReplaceEdiFormatDocumentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ReplaceEdiFormatDocument")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partners/{partnerId}/ediFormats/{format}/documents/{docId}"
	localVarPath = strings.Replace(localVarPath, "{"+"docId"+"}", _neturl.PathEscape(parameterToString(r.docId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"format"+"}", _neturl.PathEscape(parameterToString(r.format, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partnerId"+"}", _neturl.PathEscape(parameterToString(r.partnerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultApiApiReplaceEndpointRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	endpointId string
	environmentId string
	organizationId string
	endpoint *Endpoint
}

func (r DefaultApiApiReplaceEndpointRequest) Endpoint(endpoint Endpoint) DefaultApiApiReplaceEndpointRequest {
	r.endpoint = &endpoint
	return r
}

func (r DefaultApiApiReplaceEndpointRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ReplaceEndpointExecute(r)
}

/*
 * ReplaceEndpoint Method for ReplaceEndpoint
 * Replace endpoint
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param endpointId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiReplaceEndpointRequest
 */
func (a *DefaultApiService) ReplaceEndpoint(ctx _context.Context, endpointId string, environmentId string, organizationId string) DefaultApiApiReplaceEndpointRequest {
	return DefaultApiApiReplaceEndpointRequest{
		ApiService: a,
		ctx: ctx,
		endpointId: endpointId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ReplaceEndpointExecute(r DefaultApiApiReplaceEndpointRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ReplaceEndpoint")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/endpoints/{endpointId}"
	localVarPath = strings.Replace(localVarPath, "{"+"endpointId"+"}", _neturl.PathEscape(parameterToString(r.endpointId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.endpoint == nil {
		return nil, reportError("endpoint is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.endpoint
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultApiApiReplaceIdentifierRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	identifierId string
	partnerId string
	environmentId string
	organizationId string
	identifier *Identifier
}

func (r DefaultApiApiReplaceIdentifierRequest) Identifier(identifier Identifier) DefaultApiApiReplaceIdentifierRequest {
	r.identifier = &identifier
	return r
}

func (r DefaultApiApiReplaceIdentifierRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ReplaceIdentifierExecute(r)
}

/*
 * ReplaceIdentifier Method for ReplaceIdentifier
 * Replace identifier
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param identifierId
 * @param partnerId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiReplaceIdentifierRequest
 */
func (a *DefaultApiService) ReplaceIdentifier(ctx _context.Context, identifierId string, partnerId string, environmentId string, organizationId string) DefaultApiApiReplaceIdentifierRequest {
	return DefaultApiApiReplaceIdentifierRequest{
		ApiService: a,
		ctx: ctx,
		identifierId: identifierId,
		partnerId: partnerId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ReplaceIdentifierExecute(r DefaultApiApiReplaceIdentifierRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ReplaceIdentifier")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partners/{partnerId}/identifiers/{identifierId}"
	localVarPath = strings.Replace(localVarPath, "{"+"identifierId"+"}", _neturl.PathEscape(parameterToString(r.identifierId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partnerId"+"}", _neturl.PathEscape(parameterToString(r.partnerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.identifier == nil {
		return nil, reportError("identifier is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identifier
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultApiApiReplaceMappingRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	mappingsId string
	documentflowId string
	environmentId string
	organizationId string
	documentMappingConfig *DocumentMappingConfig
}

func (r DefaultApiApiReplaceMappingRequest) DocumentMappingConfig(documentMappingConfig DocumentMappingConfig) DefaultApiApiReplaceMappingRequest {
	r.documentMappingConfig = &documentMappingConfig
	return r
}

func (r DefaultApiApiReplaceMappingRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ReplaceMappingExecute(r)
}

/*
 * ReplaceMapping Method for ReplaceMapping
 * Replace mapping
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param mappingsId
 * @param documentflowId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiReplaceMappingRequest
 */
func (a *DefaultApiService) ReplaceMapping(ctx _context.Context, mappingsId string, documentflowId string, environmentId string, organizationId string) DefaultApiApiReplaceMappingRequest {
	return DefaultApiApiReplaceMappingRequest{
		ApiService: a,
		ctx: ctx,
		mappingsId: mappingsId,
		documentflowId: documentflowId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ReplaceMappingExecute(r DefaultApiApiReplaceMappingRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ReplaceMapping")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/documentflows/{documentflowId}/mappings/{mappingsId}"
	localVarPath = strings.Replace(localVarPath, "{"+"mappingsId"+"}", _neturl.PathEscape(parameterToString(r.mappingsId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"documentflowId"+"}", _neturl.PathEscape(parameterToString(r.documentflowId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.documentMappingConfig == nil {
		return nil, reportError("documentMappingConfig is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.documentMappingConfig
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultApiApiReplacePartnerRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	partnerId string
	environmentId string
	organizationId string
	partner *Partner
}

func (r DefaultApiApiReplacePartnerRequest) Partner(partner Partner) DefaultApiApiReplacePartnerRequest {
	r.partner = &partner
	return r
}

func (r DefaultApiApiReplacePartnerRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ReplacePartnerExecute(r)
}

/*
 * ReplacePartner Method for ReplacePartner
 * Replace partner
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param partnerId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiReplacePartnerRequest
 */
func (a *DefaultApiService) ReplacePartner(ctx _context.Context, partnerId string, environmentId string, organizationId string) DefaultApiApiReplacePartnerRequest {
	return DefaultApiApiReplacePartnerRequest{
		ApiService: a,
		ctx: ctx,
		partnerId: partnerId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) ReplacePartnerExecute(r DefaultApiApiReplacePartnerRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ReplacePartner")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/partners/{partnerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"partnerId"+"}", _neturl.PathEscape(parameterToString(r.partnerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.partner == nil {
		return nil, reportError("partner is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.partner
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultApiApiUpdateCustomAttributeRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	customAttributeId string
	environmentId string
	organizationId string
	customAttribute *CustomAttribute
}

func (r DefaultApiApiUpdateCustomAttributeRequest) CustomAttribute(customAttribute CustomAttribute) DefaultApiApiUpdateCustomAttributeRequest {
	r.customAttribute = &customAttribute
	return r
}

func (r DefaultApiApiUpdateCustomAttributeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UpdateCustomAttributeExecute(r)
}

/*
 * UpdateCustomAttribute Method for UpdateCustomAttribute
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param customAttributeId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiUpdateCustomAttributeRequest
 */
func (a *DefaultApiService) UpdateCustomAttribute(ctx _context.Context, customAttributeId string, environmentId string, organizationId string) DefaultApiApiUpdateCustomAttributeRequest {
	return DefaultApiApiUpdateCustomAttributeRequest{
		ApiService: a,
		ctx: ctx,
		customAttributeId: customAttributeId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) UpdateCustomAttributeExecute(r DefaultApiApiUpdateCustomAttributeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateCustomAttribute")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/customAttributes/{customAttributeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"customAttributeId"+"}", _neturl.PathEscape(parameterToString(r.customAttributeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.customAttribute == nil {
		return nil, reportError("customAttribute is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.customAttribute
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type DefaultApiApiUpdateDocumentflowRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	documentflowId string
	environmentId string
	organizationId string
	documentFlow *DocumentFlow
}

func (r DefaultApiApiUpdateDocumentflowRequest) DocumentFlow(documentFlow DocumentFlow) DefaultApiApiUpdateDocumentflowRequest {
	r.documentFlow = &documentFlow
	return r
}

func (r DefaultApiApiUpdateDocumentflowRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UpdateDocumentflowExecute(r)
}

/*
 * UpdateDocumentflow Method for UpdateDocumentflow
 * Patches documentflow
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param documentflowId
 * @param environmentId
 * @param organizationId
 * @return DefaultApiApiUpdateDocumentflowRequest
 */
func (a *DefaultApiService) UpdateDocumentflow(ctx _context.Context, documentflowId string, environmentId string, organizationId string) DefaultApiApiUpdateDocumentflowRequest {
	return DefaultApiApiUpdateDocumentflowRequest{
		ApiService: a,
		ctx: ctx,
		documentflowId: documentflowId,
		environmentId: environmentId,
		organizationId: organizationId,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) UpdateDocumentflowExecute(r DefaultApiApiUpdateDocumentflowRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateDocumentflow")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/environments/{environmentId}/documentflows/{documentflowId}"
	localVarPath = strings.Replace(localVarPath, "{"+"documentflowId"+"}", _neturl.PathEscape(parameterToString(r.documentflowId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environmentId"+"}", _neturl.PathEscape(parameterToString(r.environmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", _neturl.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.documentFlow == nil {
		return nil, reportError("documentFlow is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.documentFlow
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
